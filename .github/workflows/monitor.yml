# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Iran Internet Monitor â€” Uptime Check
# Runs every 5 minutes, checks all API endpoints, commits results
# Inspired by Upptime (https://github.com/upptime/upptime)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "Uptime CI"

on:
  schedule:
    - cron: "*/5 * * * *"
  repository_dispatch:
    types: [uptime]
  workflow_dispatch:
    inputs:
      force:
        description: "Force check all services (ignore intervals)"
        type: boolean
        default: false

permissions:
  contents: write
  issues: write

jobs:
  check:
    name: "Check endpoint status"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || github.token }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"
          cache-dependency-path: check/go.sum

      - name: Install jq (for page-data and commit steps)
        run: sudo apt-get update -qq && sudo apt-get install -y -qq jq netcat-openbsd

      - name: ICMP ping (smoke test)
        run: |
          echo "ICMP ping â†’ Google DNS"
          ping -c 4 -W 8 8.8.8.8 || echo "â†’ packet loss or high latency (non-fatal)"

      - name: TCP connectivity (inline â€” nc, no Go)
        run: |
          mkdir -p api history
          now_iso=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          now_epoch=$(date +%s)
          touch incidents.log
          tcp_services=$(jq -rc '.categories[].services[] | select(.type == "tcp") | "\(.id)|\(.name)|\(.url)"' config.json)
          for line in $tcp_services; do
            IFS='|' read -r id name url <<< "$line"
            [ -z "$id" ] && continue
            host="${url%%:*}"
            port="${url##*:}"
            start_ms=$(($(date +%s%3N)))
            if nc -zv -w 8 "$host" "$port" 2>/dev/null; then
              end_ms=$(($(date +%s%3N)))
              rt=$((end_ms - start_ms))
              status="up"
              value=100
              code=1
              msg="TCP OK ${rt}ms ($url)"
            else
              rt=0
              status="down"
              value=0
              code=0
              msg="TCP failed ($url)"
            fi
            prev=$(jq -r '.prev_status // .status // "unknown"' api/"$id".json 2>/dev/null || echo "unknown")
            hist_file="history/${id}.csv"
            if [ -f "$hist_file" ]; then
              total=$(wc -l < "$hist_file")
              up_count=$(awk -F, '$2=="up"' "$hist_file" | wc -l)
              [ "$total" -gt 0 ] && uptime_pct=$(awk "BEGIN {printf \"%.0f\", 100*$up_count/$total}") || uptime_pct=100
            else
              uptime_pct=100
            fi
            echo "$now_iso,$status,$value,$rt,$code" >> "$hist_file"
            jq -n \
              --arg id "$id" --arg name "$name" --arg status "$status" --arg msg "$msg" \
              --argjson value $value --argjson rt $rt --argjson code $code \
              --argjson uptime_pct $uptime_pct --arg prev "$prev" --arg lc "$now_iso" --argjson le "$now_epoch" \
              '{id:$id, name:$name, check_type:"tcp", status:$status, message:$msg, value:$value, response_time_ms:$rt, jitter_ms:0, http_code:$code, uptime_pct:$uptime_pct, last_check:$lc, last_check_epoch:$le, prev_status:$prev}' \
              > api/"$id".json
            if [ "$prev" != "unknown" ] && [ "$prev" != "$status" ]; then
              echo "${now_iso}|${id}|${name}|${prev}|${status}|${msg}" >> incidents.log
            fi
            echo "  TCP $status: $name ($url)"
          done
          echo "TCP checks done."

      - name: Run checks (Go â€” HTTP/API only; TCP done above)
        run: |
          cd check && go build -o ../checker . && cd .. && ./checker

      - name: Process incidents (GitHub Issues)
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || github.token }}
        run: |
          if [ ! -f incidents.log ] || [ ! -s incidents.log ]; then
            echo "No incidents to process"
            exit 0
          fi

          while IFS='|' read -r timestamp id name prev_status new_status message; do
            [ -z "$id" ] && continue

            if [ "$new_status" = "down" ] || [ "$new_status" = "degraded" ]; then
              # Check if issue already exists
              existing=$(gh issue list --label "status:${new_status}" --label "service:${id}" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")

              if [ -z "$existing" ]; then
                status_emoji="ğŸ”´"
                [ "$new_status" = "degraded" ] && status_emoji="ğŸŸ¡"

                gh issue create \
                  --title "${status_emoji} ${name} is ${new_status}" \
                  --body "**Service:** ${name} (\`${id}\`)
          **Status:** ${prev_status} â†’ **${new_status}**
          **Time:** ${timestamp}
          **Details:** ${message}

          ---
          This issue was automatically created by [Iran Internet Monitor](https://github.com/${{ github.repository }}).
          It will be closed automatically when the service recovers." \
                  --label "status:${new_status},service:${id},automated" 2>/dev/null || true
              else
                gh issue comment "$existing" \
                  --body "**Update** (${timestamp}): Status changed to **${new_status}** â€” ${message}" 2>/dev/null || true
              fi

            elif [ "$new_status" = "up" ] && [ "$prev_status" != "unknown" ]; then
              for label in "status:down" "status:degraded"; do
                issues=$(gh issue list --label "$label" --label "service:${id}" --state open --json number --jq '.[].number' 2>/dev/null || echo "")
                for issue_num in $issues; do
                  [ -z "$issue_num" ] && continue
                  gh issue comment "$issue_num" \
                    --body "**Resolved** (${timestamp}): ${name} is back to **up** â€” ${message}" 2>/dev/null || true
                  gh issue close "$issue_num" \
                    --comment "âœ… Service recovered. Closing automatically." 2>/dev/null || true
                done
              done
            fi
          done < incidents.log

          > incidents.log

      - name: Generate status page data
        run: |
          echo '{"generated":"'"$(date -u +"%Y-%m-%dT%H:%M:%SZ")"'","services":[' > api/page-data.json
          first=true
          for f in api/*.json; do
            fname=$(basename "$f")
            [ "$fname" = "summary.json" ] && continue
            [ "$fname" = "page-data.json" ] && continue
            if $first; then first=false; else echo "," >> api/page-data.json; fi
            cat "$f" >> api/page-data.json
          done
          echo '],' >> api/page-data.json
          echo '"summary":' >> api/page-data.json
          cat api/summary.json >> api/page-data.json
          echo ',"categories":' >> api/page-data.json
          jq '[.categories[] | {name, icon, service_ids: [.services[].id]}]' config.json >> api/page-data.json
          echo '}' >> api/page-data.json

      - name: Update README with live status
        run: cd scripts && go run .

      - name: Commit & push
        run: |
          git config user.name "Iran Internet Monitor [bot]"
          git config user.email "bot@iran-internet-monitor.github.io"
          git add -A
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            SUMMARY=$(cat api/summary.json | jq -r '"Status: \(.up) up, \(.degraded) degraded, \(.down) down | Overall: \(.overall_status)"' 2>/dev/null || echo "Check complete")
            git commit -m "ğŸ“Š ${SUMMARY}"
            git push
          fi
